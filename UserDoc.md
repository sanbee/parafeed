# parafeed: A simple embedded user interface #

### Abstract: ###
_parafeed_ is a library for an embedded user interface that can be
easily put on a C/C++ program that depends on a number of parameters.
The parameters can be passed to the program either as a list of
`<NAME>=<VALUE>` on the command-line or can be set in an interactive
session.  This code is derived from the older
[CL-Lib](http://www.aoc.nrao.edu/~sbhatnag/softwares.html\#CLLIB) library.

When compiled with GNU Readline support, context sensitive TABBED
completion is automatically available in interactive sessions.  When a
list of all possible values that a parameter can accept is available,
TABBBED completion can be used to view and set value of
parameters in a context sensitive manner.

End users typically need simple changes to the user interface but need to make these changes often depending upon the immediate need (e.g. name of the parameters, when to make which parameter visible in the interface, the default value of the parameters, etc.).  For the end user to depend for such needs on the programmers can easily lead to non-optimal use of the time of end users as well as the programmers. _parafeed_ implements a number of mechanism to greatly reduce this dependence of the end-user on the programmers for simple user interface issues.


The interactive shell supports context sensitive hiding/exposing of keywords (referred to as _parameter_ _unwinding_), similar to the
parameter-unfolding implemented in the
[CASA](http://casa.nrao.edu) package.
This allows producing a number of specializations from
a single binary executable where only the minimum required parameters
are presented to the user.  The shell itself is customizable via
environment variables and additional command-line arguments.


Specializations can also be produced from the same binary by setting up configuration files where the values of the parameters can be set.  The configuration file is independent for each application and each user can have her/his own configuration files.  Alternatively, a system wide configuration files can also be set up.  The values set in the configuration file overrides the default values that were set by the programmer at the time of compilation.

Parameters can also be designated as shell constants.  The value of shell constants can be set in the configuration files but such parameters are not visible in the user interface and cannot be set by the user.  A new virtual application can be easily generated by users by (1) setting up a symbolic link with a new name to the application binary, (2) setting up the configuration file with same name as the symbolic link.  This thus provides an easy and flexible mechanism for users to generated any number of virtual applications (via differently named symbolic links) and be able to control the user interface (via the configuration files) without the need to change the source code/binary files.

## Usage ##

Applications using _parafeed_ can be used as interactive programs
where the parameters of the program can be set interactively by the user.
Alternatively, the application can be used as a non-interactive program where the parameters are given as `<NAME>=<VALUE>` list on the command-line.

## Interactive mode ##

This is the default mode.  Upon startup, applications will present a
list of its parameters in the form of keyword names followed by their
current values.  The default values displayed will be
those set by the application programmer.  The settings of the various
keywords can be stored in a file.  If a file with the same name as the
application executable file name with an extension ".def" is
found (see Section on **Customization**), the values of the keywords will be
loaded from that file.  The value of the keywords can also be set on
the command-line in the `<KeyWord>=[<Val0>[,<Val1>[...]]]`
format.  This style of setting the initial value of the keywords will
over-ride the above mentioned mechanisms for setting the keyword
values.

### User Commands ###
In the interactive sessions, a simple shell allows setting/un-setting
of the listed keyword values.  Following commands are available in the
shell:

```
 inp         : To see the various keywords and the values they have been set to
 go          : To run the application
 gob         : To run the application in background
 cd          : Change working directory
 help        : This help
 ?           : Information on all keywords, optionally on a single keyword
 explain     : Detailed help, optionally of keywords/task [[Key][:Task]]
 save        : Save the values, optionally in a file
 savecmd     : Save the settings as UNIX shell command string
 load        : Load the values, optionally from a file
 edit        : Use an editor to (un)set the values
 quit        : Quit the application
```

These commands form the standard set of shell commands available in
all applications using _parafeed_.  Mechanism exists to add
application specific commands, or suppress any of the above standard
commands, if the application programmer chooses to do so.  The
"help" command is always expected to show all the commands available.

The keywords can be set/reset from this shell by commands of type
`<KeyWord>=<Val>`.  The shell uses the minimum match algorithm for the keywords.

Following is a short description of the shell commands:

  * `inp:`
> > Display the current setting of all the keywords.  If a keyword is given as an argument, the
> > setting of only that keyword will be displayed.

  * `go:`
> > End of the interactive session.  The current value of the keywords are used
> > and the application resumes normal execution.

  * `gob:`
> > Similar to `go` except that it will run the application in the background and print the
> > process ID (PID) number of the background process on the screen (also see section on **CUSTOMIZATION**).

  * `cd:`
> > Change the current working directory within the interactive shell.

  * `'?':`
> > Print some basic information about the type, the number of values the keywords expects,
> > factory settings for the keywords and list of options, if available.  If a keyword is given as an argument,
> > information about only that keyword will be printed.

  * `explain:`
> > Print as detailed a help about the application and the keywords as the author of the
> > application has cared to write in the help file.  These help files are located in the directory specified by
> > the environment variable `GDOC` (see section on **CUSTOMIZATION**).

  * `save:`
> > Save the current setting of the keywords in a file.  By default, these values are saved in a
> > file named `./<Application Name>.def`.  If a file name is supplied as an argument of this command,
> > the values will be saved in the file.

  * `savecmd:`
> > Save the current setting of the keywords in a file in the form of a UNIX command.  By
> > default, these values are saved in a file named `./<Application Name>.cmd`.  If a file name is
> > supplied as an argument of this command, the values will be saved in the file.

  * `load:`
> > Load the values of keywords from a file. By default it loads the settings for the keywords
> > from the file `./<Application Name>.def`.  If this file is already present when the application is
> > started, it is loaded automatically.  Alternatively, it can load settings from a file provided as an argument
> > to the `load` command.

  * `edit:`
> > Edit the keyword values in an editor of choice specified by the environment variable
> > `EDITOR` (see section on **CUSTOMIZATION**).

  * `quit:`
> > Quits the interactive session without executing the application.

All inputs to the interactive shell, which are not any of the above
mentioned commands or any of the application specific commands, are
passed to the underlying Operating System (OS) user shell.  Hence,
most of the native OS commands shall still be available from this
shell.  (Users however must be aware that certain OS shell commands
like "`setenv`" (for `csh` users) or "`export`" (for
`bash/sh` users) will seem to work, but will not have the desired
effect).

The values of the keywords can be a list of comma-separated values.
The expected number of values will be reported by the shell-command
`'?'` along with the type of the values, enclosed in '`[ `'
and '`]`' pairs.  A blank set of square brackets ("`[]`")
will be printed for keywords which can accept any number of values.
Some keywords may accept values of mixed types (e.g., string, floats,
integers).  For such keywords, the reported type will be "`Mixed`".

Comma is treated as a separator in a list of values for a keyword.  To
suppress its interpretation as a separator, it can to be "escaped"
using the backslash ('`/`') before the comma.  For example,
if the value of a keyword `key` has to be set to a string `"Funny, value with a comma"`, it can be done using

```
                key=Funny\, value with a comma
```

The characters '`/`', '`[`', '`]`', '`=`', which
are part of the shell-command syntax, must also be escaped similarly
to be used as part of the values of the keywords.

Numeric values of keywords can be arbitrary mathematical expressions.
Following functions and constants can be used in these expression:

  * Functions: sin,cos,tan,asin,acos,atan,atan2,sinh,cosh,tanh,exp,ln,log,flog10,sqrt,fabs,floor,ceil,rint

  * Constants:
    1. `PI:` value of pi
    1. `C:` speed of light in meters per second.
    1. `R2D,D2R:` multiplicative constants for conversion from Radians to Deg. and vice versa
    1. `H2R,R2H:` multiplicative constants for conversion from Hours to Radians and vice versa
    1. `SOL2SID,SID2SOL:` multiplicative constants for conversion from Solar to Sidreal time and vice versa

Numbers in the expression can be in any of the following representations:

  * Integer format, real (float) format
  * 1.0E-1 or 1.0e-1 (=0.1)
  * 1.0D-1 or 1.0d-1 (=0.1)
  * 1h10m0.1s: the time format - converts the number to seconds before using it.
  * `1d1'1"`: The angular format - converts to arc seconds before using it.

(`1d1' = 3660.0"` and `-1d1' = -3660.0"`)

### De-referencing mechanism ###

The user interface system allows the application programmers to define
shell symbols which are treated as constants (i.e. their values cannot
be modified by the user).  These symbols are referred to as the
`const symbols`.  Some applications may load a number of
frequently used values of various keywords as `const symbols`.
However, by default, none of the `const symbols` are presented to
the user and it is the responsibility of application programmer to add
extra shell-commands for viewing the list of `const symbols`.

Values can be transfered from one keyword or a `const symbol` to
another keyword.  E.g. to transfer the i^{th} value from keyword
`Key1` to a keyword `Key2`, one could use `Key2=$Key1[i]`.  `Key2=$Key1` will transfer all values of `Key1`
to `Key2`.

### TABBED completion ###

TABBED completion is available, when the library is compiled with GNU
Readline support.

At the interactive shell prompt, two TABs will display the list of
shell commands and keywords available for completion.  A TAB after a
completed keyword will add the '=' sign.  Two TABs after this will
print the list of available options for the completed keyword.  If no
options are available (typically because the list of possible values
that the keyword can accept is infinite - e.g. list of integers),
further TABs will have no effect.

For keywords that accept strings, and do not have a list of options
available, GNU Readline file-name completion will be envoked.

Two TABs after a completed shell command will print a context
sensitive list of possible options.  For commands that can take a file
name as an argument, file name completion will be envoked.  For
commands that can take keywords are argument, keyword completion will
be envoked.

### Parameter unwinding (context sensitive parameter hiding/exposing) ###

For applications with a long list of possible keywords, it is useful
to expose only a minimum set of required keywords. There might be
keywords, the value of which is either irrelavent to the application
or the default value is acceptable, depending upon the value of some
other keyword.  For such applcations, keywords are exposed only if it
is required that their values be set by the user.  Displayed keywords
are colour coded to indicate if the current setting of a keyword could
be hiding other keywords, the keyword could itself be hidden by
other keywords or both (i.e., the keyword could be hiding other
keywords and could be itself hidden by other keywords).

Red coloured keyword indicates that it could be hiding other
keywords.

Blue coloured keyword indicates that this keyword could be hidden by
the setting or some other red-coloured keyword (typically, the first
red-coloured keyword above it in the list of displayed keywords).

Green coloured keywords indicate that this keyword could be hiding
other keywords and could itself be hidden by some other keyword.

## Non-interactive mode ##

The application using _parafeed_ can also be started in a
non-interactive mode by giving `"help=noprompt"` as a
command-line option.  All keywords that need to be set (i.e., default
values are not acceptable) must be listed as `<NAME>=<VALUE>`
pairs on the command-line.  E.g. an application named "myapp" with a
parameter named "key1"' can be started in the non-interactive mode
with "Value0,Value1,Value2" for the value of "key1" as:

```
myapp help=noprompt key1=Value0,Value1,Value2
```

See Section on **HELP KEYWORD** for more on the use of the `help`
command-line keyword.

## File name convention ##

Most off-line applications can perform I/O using UNIX pipes.  If the
input file name begins with '`<`', the rest of the file name is
treated as a command, the output of which becomes the input of the
application. For example, to supply the output of a program `tmac`
as the input of the program `xtract`, the "`in`" keyword of
_xtract_ must be set to `"<tmac"`.  After the shell-command
`go` is issued for `xtract`, the interface of `tmac` will
be started and the keywords of `tmac` can then be set in the
normal fashion.  When the shell-command `go` is issued again,
`tmac` will begin execution, and the output of `tmac` becomes the
input of `xtract`.  Till this time, execution of `xtract` would remain
blocked, waiting for input from `tmac`.

Similarly, if the output file name begins with the '`|`'
character, the rest of the file name is treated as a command, the
input of which becomes the output of the off-line program.

By convention, a blank output file name implies that the output would
go to the standard output stream (usually your screen) and a blank
input file name implies that the input would be read from the standard
input stream (usually your keyboard).

## Customization ##

The user interface can be customized using the following environment
variables.

  * `GDOC:` `GDOC` must point to the standard directory where documents explaining the various off-line data analysis programs are kept. The `explain` command will first look for the explanation file in the local directory and then in the directory specified by this variable.  The name of the explanation file is constructed by appending the suffix `".doc"` to the application name.

  * `GERR, GOUT:` `GERR` and `GOUT` variables are used when the application is run using the `gob` command (see section on **USER COMMANDS**).  The standard output of the application will be redirected to the file specified by `GOUT` while the standard error stream will be redirected to the file specified by `GERR`.  By default, these variables are set to `/dev/null`.

  * `GCONF`: Some applications may load frequently used setting for some keywords.  These values are loaded as constants of the interactive shell and can be stored in a configuration file.  Their values can be transfered to the application keywords by referring to their value by '$' mechanism (see section on **De-referencing Mechanism**).  The path of the directory containing these configuration files is specified by the environment variable `GCONF`.  The configuration filename is constructed by appending the suffix "`.config`" to the application name.  If `GCONF` is not defined, the application looks in the directory specified by `GDOC`.  If this variable is also not defined, or the configuration file is not found, the application will look for the configuration file in the current directory.

  * `EDITOR`:`EDITOR` environment variable is used to specify the name of the text editor to be used in the `edit` command (see section on **User Commands**).  The default editor is `emacs`.

  * `GDEFAULTS`: The default values of keywords can be saved in "defaults file".  `GDEFAULTS` variable specifies the directory where these files are stored.  Such a file can be automatically loaded by the applications upon startup.  The defaults file name is constructed by appending the suffix "`.def`" to the application name.


> By default, the application will look for the defaults file in the current directory.  If a keyword appears in the "`.def`" as well as in the "`.config`" file, the keyword will be treated as a shell constant.  This can be used to effectively produce specialized versions of an application program by writing an appropriated "`.config`", where keywords can have fixed values, not alterable by the user (e.g., a version of `xtract` which will read input from the shared memory of the GMRT data acquisition system).


The following two variables are effective only for versions of the
user interface libraries which use the GNU Readline and the History
libraries.

  * `GHIST`:`GHIST` specifies the file in which the history of the commands issued in the interactive session is saved.  This file will be common to all applications.  The default history file is `$HOME/.g_hist`.  This is also the file from which all applications will load the command history.

  * `MAXGHIST`: `MAXGHIST` should be set to the maximum number of command history entries which the user wishes to save.  By default this is set to 100.

### Customization: Parameter Unrolling ###

The keywords are categorized into the following different categories:

> "default", "hiddenseek", "hidden", "hiding"

All keywords that do not expose any hidden keywords are of "default"
category.  Keywords that hide other keywords are of "hiding" category
while those which can be hidden are of "hidden" category.  Keywords
which can be hidden and can also further expose other keywords are of
"hiddenseek" category.

The default color of the various keywords category can be set via a
file pointed to by the `GCOLOURMAP` environment variable.  The
allowed colours names are:

> "black", "red", "green", "yellow", "blue", "magenta", "cyan", "white".

The background and foreground colors of the keywords can be set
via `<KEYWORD CATEGORY>=<COLORNAME>` entries in the `GCOLOURMAP`
file where `KEYWORD CATEGORY` is constructed by appending "bg"
(for background colour) or "fg" (for foreground colour) to the keyword
category listed above.  E.g.

defaultfg=black

will set the foreground colour of all keywords of type "default" to
black.



## The 'help' keyword ##

All applications are sensitive to the keyword `help` (not to be
confused with the shell command `help` described in section on **User Commands**).  It is never displayed in the list of keywords.  To
use it, it must be specified as a command-line argument.  Following is
the list of values that can be set for this keyword on the
command-line and their effect:

  * `help=noprompt`:
> > The application runs in the non-interactive mode.  This is useful when the application is run from a shell
> > script. When run in this mode, value of all the keywords which needs to be set must be supplied on the
> > command-line (the order of the command-line options is not important).  The keywords must be fully
> > spelled in the command-line options (i.e., no minimum-match will be applicable).

  * `help=explain`:
> > This executes the `explain` command of the interactive shell (see section on **User Commands**)
> > without starting the interactive shell. If a keyword is supplied within brackets (`'('` and `')'`)
> > immediately after the `explain` string (e.g. `help=explain(out)`, help will be provided for the
> > specified keyword alone.  If an application name is also included within the brackets, separated from
> > the keyword by a colon ('`:`') (e.g. `help=explain(out:xtract)`, help for the named keyword of the
> > named application will be provided.  If the keyword is skipped (but not the colon), entire help of the
> > named application will be provided.

  * `help=doc`:
> > This results into an empty documentation file written on the standard output, in the required format, with
> > a list of keywords to which the application is sensitive.  This is for use by authors of the applications and
> > to encourage them to not only write the documentation, but also in a uniform format.

  * `help=dbg`:
> > Application programmers can define hidden keywords which are normally not displayed for the user,
> > but will be used by the application internally.  These keywords can be accessed as normal keywords
> > by setting `help` keyword to the value "`dbg`".

## Example ##
Here is a typical screen-shot of an application using _parafeed_ for user interface, when started in the interactive mode:
```
sbhatnag@langur> clean
ms            = ../TestData/data_ic2233.VLA.FullPol.2.cal.ms
imsize        = 1024*2,1024*2
cellsize      = 7,7
model         = test_ic2233.20.3.pcal
restored      =
residual      =
mask          =
complist      =
ftmachine     = myftmachine
facets        = 1
wplanes       = 1
applyoffsets  = 0
pointingtable =
cfcache       = predict.cfcache
painc         = 360
algorithm     = cs
stokes        = IV
weighting     = natural
field         = 0
spw           = 0
time          =
baseline      =
mode          = continuum
datanchan     = 20
datastart     = 6
datastep      = 1
gain          = 0.1
niter         = 1000
threshold     = 0
interactive   = 0
clean>?
   Key                Type          Factory defaults        Options
---------          ----------       ----------------        -------
  ms                    string                        
  imsize                int[2]              0,0        
  cellsize              float[2]            0,0        
  model                 string[]            
  restored              string[]            
  residual              string[]            
  mask                  string[]            
  complist              string                        
  ftmachine             string              ft         [ft wproject pbwproject pbmosaic]
  facets                int                 1         
  wplanes               int                 1         
  applyoffsets          int                 0         
  dopbcorr              int                 1         
  pointingtable         string                        
  cfcache               string                        
  painc                 float               360       
  algorithm             string              cs         [cs clark hogbom mfclark]
  stokes                string              I          [I IV IQUV]
  weighting             string              uniform    [uniform natural briggs]
  field                 Mixed[]                       
  spw                   Mixed[]                       
  time                  Mixed[]                       
  baseline              Mixed[]                       
  uvrange               Mixed[]                       
  mode                  string              continuum  [continuum spectral pseudo]
  datanchan             int[]               1         
  datastart             int[]               0         
  datastep              int[]               1         
  operation             string              clean      [clean predict psf dirty residual]
  gain                  float               0.1       
  niter                 int                 0         
  threshold             float               0         
  interactive           int                 0         
clean>algorithm<TAB><TAB>
clean>algorithm=<TAB><TAB>
clark    cs       hogbom   mfclark 
clean>algorithm=cl<TAB>
clean>algorithm=clark
```